#summary Design choices for libaudit producer

= Introduction =

Here are the design choices as well as some justification for the decisions made in the libaudit producer.


= Details =

The details of the design follow the flow of the data as it starts from the libaudit auditing framework to our our producer and onwards to the provenance kernel.

The libaudit auditing framework produces audit events for each system call. One system call may generate many audit minievents which contain information regarding that system call. The libaudit framework passes these events to an af_unix socket. Our parser reads the event stream from this socket and bundles up each system call and all its minievent. Each system call is then converted into its provenance analogue representations and passed onwards.

Although the initial plan was to keep no state whatsoever in the producer, we had to let go of this approach once we realize that the audit system does not produce enough data per system call to allow independent logging of each call. An example of this is that the read system call only has a file descriptor in it and no file path name. This means one needs to keep track of all the open files. A linked problem is of file versioning. As we do not get the file's last modified time on any call we cannot determine its version. We came up with a model that solves both these problems. Keep a map which maps the process,file descriptor(fd) pair to the file that is open and represents this descriptor in this process. Now multiple process,fd pairs might be pointing to this same file which is allowed. Whenever a write happens the file version is changed. As everyone is pointing to the same file object the version will be changed for everyone and versioning would be handled accross all processes.

Similarly we also have a process table in the producer that keeps track of active pids and stores a map of pid against the process information. So for example on a read you just need to look up the process using the pid and look up the file using the process,fd pair and you can convert it into a read edge and sent it along.

Now we are going to take a look at how each system call is converted to its analogue provenance respresentation.


Fork:
When a fork happens the process remains same except for the pid,ppid which changes. So we create a new process in the process table with all the same information except the pid and ppid. And we also create a fork edge and send the new process and edge onward.

Read:
We do not need a new process vertex as the reading process would have been created at exec time. We merely need to get its pointer from the process table. We also do not need to create a new file. It was created at open time. We just need to look up the file in file table using process,fd pair. The new thing we need to create a read edge from this process to this file and send this edge along.

Write:
We do not need a new process vertex as the reading process would have been created at exec time. We merely need to get its pointer from the process table. We also do not need to create a new file. It was created at open time. We just need to look up the file in file table using process,fd pair and increment its version. The new thing we need to create a write edge from this process to this new versioned file and send this edge along.

Open:
We do not need a new process vertex as the reading process would have been created at exec time. We merely need to get its pointer from the process table. As far as the file is concerned we might or might need to create a new file. If the file is already present in the table then we just need to add an edge to this file from the new process,fd pair we have. If the file is not the table then we need to create a new file vertex and set its logical version to 1 and then point the new process,fd pair to this file. Open itself does not have any provenance semantics as no data is flowing. An edge will be added if this open file in read or written in the future.

Close:
We do not need a new process vertex as the reading process would have been created at exec time. We merely need to get its pointer from the process table. Close also does not have any provenance semantics as no data is flowing. When a close happens we merely need to delete the process,fd to file edge in the file table.

Link:

Unlink:

Execve:
We need to create a new process on an execve. We check for the pid of the new process and get all the information regarding the process from the audit event. Then we store this new process vertex against its pid in the process table, overwriting whatever was written against that pid. As we only care about currently running processes we do not have to worry about pid wrap around as only one process can have the same pid at any given time. The only exception to this is when a process execve from another process, then it has the same pid. But as the older process is overwritten in memory it cannot make any calls and hence can be considered to be terminated.

Mknod:

Rename:
We create a new file vertex in the table in place of the old file that was renamed and also we create a file to file edge from the old file to the new file and send this along.

Dup/Dup2:
Dup merely returns a new file descriptor given an old one. So this means we just need to add a process,fd to file edge in the file map.

Pipe:

Symlink:

Socketcall:

Clone:
See Fork.

Readv:
See Read.

Writev:
See Write.

Vfork:
See Fork.