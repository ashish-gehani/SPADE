#summary Design choices for libaudit producer

= Introduction =

Here are the design choices as well as some justification for the decisions made in the libaudit producer.


= Details =

The details of the design follow the flow of the data as it starts from the libaudit auditing framework to our our producer and onwards to the provenance kernel.
The libaudit auditing framework produces audit events for each system call. One system call may generate many audit minievents which contain information regarding that system call. The libaudit framework passes these events to an af_unix socket. Our parser reads the event stream from this socket and bundles up each system call and all its minievent. Each system call is then converted into its provenance analogue representations and passed onwards. Although the initial plan was to keep no state whatsoever in the producer, we had to let go of this approach once we realize that the audit system does not produce enough data per system call to allow independent logging of each call. An example of this is that the read system call only has a file descriptor in it and no file path name. This means one needs to keep track of all the open files and what version it is.